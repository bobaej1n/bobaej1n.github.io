---
title: "[운영체제 공룡책 10th] Ch.9 메인 메모리 - 2"
description: >-
  Main Memory - 2
date: 2025-07-23 13:00:00 +0900
categories: [OS]
tags: [OS, Operating System]
pin: false
image:
  path: /assets/img/resources/OS/os_cover.png
---

## 3. 페이징 (Paging)

### 1) 기본 방법

- 물리 메모리는 동일 크기의 **프레임(frame)**으로, 논리 메모리는 동일 크기의 **페이지(page)**로 나누어짐
  - 프로세스가 실행될 때 그 프로세스의 페이지는 파일 시스템 or 예비 저장장치로부터 가용한 메인 메모리 프레임으로 적재됨
  - 예비 저장장치는 메모리 프레임 or 클러스터(프레임의 묶음)와 동일한 크기의 고정 크기 블록으로 나눠짐

    ![9.8](/assets/img/resources/OS/ch9/9.8.png){: width="450" .normal }

- CPU에서 나오는 모든 주소는 페이지 번호(p)와 페이지 오프셋(d: offset) 두 부분으로 나누어짐
  - 페이지 번호: 페이지 테이블에서 프레임 번호를 찾기 위한 인덱스로 사용됨
  - 페이지 테이블: 물리 메모리의 각 프레임의 시작 주소를 저장함
  - 페이지 오프셋: 참조되는 프레임 안에서의 위치

    ![9.9](/assets/img/resources/OS/ch9/9.9.png){: width="400" .normal }

- 특징
  - **외부 단편화 없음**
  - 마지막 페이지가 프로세스 크기와 정확히 맞지 않는 경우 **내부 단편화** 발생
  - 페이지 크기 2^n 단위 일반적 (e.g., 4KB)

- 페이지 크기와 효율
  - 작을 경우: 단편화는 줄지만 페이지 수가 많아져 페이지 테이블이 커짐
  - 클 경우: 테이블은 작지만 단편화는 커짐
  - 일부 시스템은 2MB 이상의 **대형 페이지(Huge Page)**도 지원함

---

### 2) 하드웨어 지원

- MMU & PTBR
  - MMU: 페이지 테이블을 참조하여 논리 주소를 물리 주소로 변환
  - **PTBR** (Page Table Base Register): 현재 페이지 테이블 시작 주소 저장

- **TLB** (Translation Lookaside Buffer): 페이지 테이블 참조를 빠르게 하기 위한 캐시
  - 페이지 번호 → 프레임 번호 매핑을 캐싱 (associative memory)
  - TLB hit 시 빠른 변환, miss 시 페이지 테이블 접근
  - 성능은 **적중률(hit ratio)**에 따라 좌우됨

    ![9.12](/assets/img/resources/OS/ch9/9.12.png){: width="400" .normal }

- 예시
  - TLB 접근: 10ns, 메모리 접근: 100ns
  - hit ratio = 80%
	```
	EMAT(Effective memory Access Time, 실질 메모리 접근 시간)
	= 0.8 * 10ns + 0.2 * (10 + 100)ns
	= 30ns
	```

---

### 3) 보호

- 페이징 환경에서 메모리 보호는 각 페이지에 붙어있는 보호 비트에 의해 구현됨
  - 이 비트들은 보통 페이지 테이블에 속해 있음
  - 잘못된 접근 시 `memory protection violation` 발생

- **유효/무효 (valid/invalid) 비트**
  - valid: 관련 페이지가 프로스세의 합법적인 페이지임을 나타냄
  - invalid: 해당 페이지가 프로세스의 논리 주소 공간에 속하지 않음을 나타냄

- **PTLR** (page table length register, 페이지 테이블 길이 레지스터)
  - 프로세스가 자신의 모든 주소 범위를 늘 사용하는 경우는 드묾 → 모든 페이지에 페이지 테이블 항목을 배정하는 것은 낭비
  - 프로세스가 제시한 주소가 유효한 범위 내에 있는지 확인하기 위해 모든 논리 주소 값이 PTLR 값과 비교되며 오류 발견시 트랩 발생시킴

    ![9.13](/assets/img/resources/OS/ch9/9.13.png){: width="400" .normal }

---

### 4) 공유 페이지

- 페이징의 장점은 공통의 코드를 공유할 수 있음
  - 여러 프로세스가 같은 프로그램 코드나 라이브러리를 실행
  - 코드 영역은 읽기 전용이므로 하나만 메모리에 올려서 공유 가능
  - 각 프로세스는 해당 영역을 자신의 페이지 테이블에서 참조

- ex) **libc** 공유
  - libc 코드 → 하나의 물리 프레임
  - 각 프로세스는 페이지 테이블로 해당 프레임을 가리킴 → 메모리 절약

---

## 4. 페이지 테이블의 구조

### 1) 계층적 페이징 (Hierarchical Paging)

- 모든 페이지 테이블을 여러 개의 작은 조각으로 나누는 것

  ![9.15](/assets/img/resources/OS/ch9/9.15.png){: width="300" .normal }


- 문제점: 
  - 32비트 주소 공간 + 4KB 페이지 사용 시 2²⁰ (약 100만)개의 페이지 필요
  - 단일 페이지 테이블: 1M * 4B = 4MB → 너무 큼

- 해결 방법: 
  - 페이지 테이블을 계층 구조로 나눔
  - **2단계 페이징 (Two-level paging)**

- 32비트 논리 주소 분할

  | 필드        | 비트수 | 설명 |
  |-------------|--------|------|
  | `p1`        | 10     | 바깥(outer) 페이지 테이블 인덱스 |
  | `p2`        | 10     | 안쪽(inner) 페이지 테이블 인덱스 |
  | `d`         | 12     | 페이지 오프셋 |

- 64비트 주소 공간
  - 2단계로도 부족 → 3단계 또는 7단계 필요 (ex. UltraSPARC)

---

### 2) 해시 페이지 테이블 (Hashed Page Tables)

- 해시 함수를 사용하여 페이지 번호를 해시 테이블 인덱스로 변환

  ![9.17](/assets/img/resources/OS/ch9/9.17.png){: width="350" .normal }

- 특징
  - 32bit 주소 공간보다 클 때 효율적
  - 해시 충돌 시 연결 리스트로 해결

- 해시 테이블 항목 구성
  - 논리 페이지 번호
  - 물리 프레임 번호
  - 다음 항목 포인터

- 변형 구조: **클러스터 페이지 테이블**
  - 각 항목이 여러 페이지를 커버
  - 연속된 주소 공간을 커버할 때 효율적

---

### 3) 역 페이지 테이블 (Inverted Page Table)

- 기존 구조의 문제: 프로세스마다 페이지 테이블 → 메모리 낭비
- 해결 방법: 시스템 전체에 하나의 테이블만 사용

- 구조

  ![9.18](/assets/img/resources/OS/ch9/9.18.png){: width="350" .normal }

  - 각 항목: 물리 프레임 하나에 대응
  - 저장 정보: `<process-id, page-number>`
  - 논리 주소 접근 시 테이블 탐색 필요

- 단점
  - 탐색 시간 오래 걸림 → 해결책: TLB 사용
  - 다중 프로세스에서 같은 가상 주소를 가질 수 없음

---

### 4) Oracle SPARC Solaris

- 환경: 64비트 SPARC CPU + Solaris OS
- 방법: 해시 페이지 테이블 사용

- **TSB (Translation Storage Buffer)**
  - 자주 사용하는 변환 캐시
  - TLB 미스 시 → TSB 탐색 → 해시 테이블 탐색
  - MMU에 의해 자동으로 TLB에 로드됨

- 장점
  - 모든 프로세스가 공유하는 하나의 해시 테이블 유지
  - 페이지 테이블 크기 감소 + 효율적 변환
