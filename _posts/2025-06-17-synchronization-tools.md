---
title: "[운영체제 공룡책 10th] Ch.6 동기화 도구들 - 1"
description: >-
  Synhronization Tools - 1
date: 2025-06-17 13:00:00 +0900
categories: [OS]
tags: [OS, Operating System]
pin: false
image:
  path: /assets/img/resources/os_cover.png
---

## 1. 배경

프로세스가 병행 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터의 무결성에 어떤 문제를 일으키는지에 관해 설명한다.

- 협력적 프로세스
  - 시스템 내에서 실행 중인 다른 프로세스의 실행에 영향을 주거나 영향을 받는 프로세스
  - 논리 주소 공간(코드 및 데이터)을 직접 공유하거나 공유 메모리 또는 메시 지 전달을 통해서만 데이터를 공유할 수 있음

- 생산자 코드
```c
while (true)
{
    /* produce an item in. next .produced */
    
    while (count == BUFFER_SIZE)
      ; /* do nothing */
        
    buffer[in] = next .produced;
    in (in + 1) % BUFFER_SIZE;
    count++;
}
```

- 소비자 코드
```c
while (true)
{
    while (count 0)
      ; /* do nothing */
        
    next.consumed = buffer [out] ;
    out = (out + 1) % BUFFER_SIZE;
    count--;
    
    /* consume the item in next.consumed */
}
```
  - 위의 생산자와 소비자 코드는 개별적으로는 올바를지라도, 그들을 병행적으로 수행시키면 올바르게 동작하지 않음
  - 유일한 올바른 결과는 `count == 5`이고 이 결과는 생산자와 소비자의 실행이 분리되었을 때 얻을 수 있음
  - `count++`와 `count-` 문장을 병행하게 실행하는 것은 앞에서 제시한 저수준의 문장들을 임의의 순서로 뒤섞어 순차적으로 실행하는 것과 동등함

- 왜 이런 문제가 발생할까 ?
  - 두 개의 프로세스가 동시에 변수 count를 조작하도록 허용했기 때문
  - **경쟁 상황(race condition)**: 동시에 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황
  - 위와 같은 경쟁 상황으로부터 보호하기 위해, 한순간에 하나의 프로세스만이 변수 count를 조작하도록 보장해야함. 이러한 보장을 위해,  어떤 형태로든 프로세스들이 동기화되도록 할 필요가 있음


---

## 2. 임계구역 문제

- 각 프로세스는 **임계구역 (critical section)** 이라고 부르는 코드나 이상의 다른 프로세스와 공유하는 데이터에 접근하고 갱신할 수 있음
  - 한 프로세스가 자신의 임계구역에서 수행하는 동안에는 다른 프로세스들은 그들의 임계구역에 들어갈 수 없음
  - 동시에 두 프로세스는 그들의 임계구역 안에서 실행할 수 없음

- 임계구역 문제
  - 프로세스들이 데이터를 협력적으로 공유하기 위하여 자신들의 활동을 동기화할 때 사용할 수 있는 프로토콜을 설계하는 것. 각 프로세스는 자신의 임계구역으로 진입하려면 **진입 허가를 요청**해야 함
  - **진입 구역(entry section)**: 진입 허가 요청을 구현하는 코드 부분
  - **퇴출 구역(exit section)**: 임계구역 뒤에 따라옴
  - **나머지 구역(remainder section)**: 코드의 나머지 부분들 총칭
  ```c
    while (true)
    {
      entry section
        /* critical section */
      exit section
        /* remainder section */
    }
  ```

- 임계구역 문제 해결안의 3가지 요구 조건 ⭐
  1. **상호 배제(mutual exclusion)**: 프로세스 Pi가 자기의 임계구역에서 실행된다면, 다른 프로세스들은 그들 자신의 임계구역에서 실행될 수 없다.
  2. **진행(progress)**: 자기의 임계구역에서 실행되는 프로세스가 없고 그들 자신의 임계구역으로 진입하려고 하는 프로세스들이 있다면, 나머지 구역에서 실행 중이지 않은 프로세스들만 다음에 누가 그 임계구역으로 진입할 수 있는지를 결정하는 데 참여할 수 있으며, 이 선택은 무한정 연기될 수 없다.
  3. **한정된 대기(bounded waiting)**: 프로세스가 자기의 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 그들 자신의 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다. → 기아 상태 방지

- pid를 배정할 때의 경쟁 조건

  ![pid_race_condition](/assets/img/resources/250617/pid_race_condition.png){: width="450" }

  - 커널 변수 `next_available_pid`에 경쟁 조건이 있으며, 이 변수는 다음 사용 가능한 프로세스 식별자의 값을 나타냄
  - 상호 배제가 제공되지 않으면 동일한 프로세스 식별자 번호가 두 개의 다른 프로세스에 배정될 수 있음

- 경쟁 조건이 발생하기 쉬운 커널 자료구조
  - 메모리 할당을 관리하는 자료구조, 프로세스 리스트를 유지하는 자료구조, 인터럽트 처리를 위한 자료구조
  - 운영체제에서 이러한 경쟁 조건이 발생하지 않도록 보장하는 것은 커널 개발자의 책임

- 임계구역을 다루는 두 가지 접근법
  1. 선점형 커널
    - 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용
    - 공유되는 커널 자료구조에서 경쟁 조건이 발생하지 않는다는 것을 보장하도록 신중하게 설계되어야 함
    - 커널 모드 프로세스가 대기 중인 프로세스에 처리기를 양도하기 전에 오랫동안 실행할 위험이 적어 선호함
  2. 비선점형 커널
    - 커널 모드에서 수행되는 프로세스의 선점을 허용하지 않고 커널 모드 프로세스는 커널을 빠져나갈 때까지 또는 봉쇄될 때까지 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 수행
    - 한순간에 커널 안에서 실행 중인 프로세스는 하나밖에 없으므로 커널 자료구조에 대한 경쟁 조건 필요 X

---

## 3. Peterson의 해결안

- 개요
  - 두 개의 프로세스(P₀, P₁) 가 임계구역(Critical Section)을 사용할 때 상호 배제(Mutual Exclusion)를 보장함
  - **공유 변수 두 개** 사용:
    - `boolean flag[2]`: 각 프로세스가 임계구역에 들어가기를 원하는지를 나타냄
    - `int turn`: 임계구역에 누가 먼저 진입할지를 결정하는 변수

- 변수 의미
  ```c
  int turn;
  boolean flag[2];
  ```
  - `flag[i] = true`: Pᵢ가 임계구역에 진입하고 싶음을 나타냄
  - `turn = j`: Pᵢ는 Pⱼ에게 먼저 임계구역 진입 기회를 양보함

- 알고리즘 구조 (Pᵢ 관점)
  ```c
  int turn;
  boolean flag[2];

  while (true)
  {
    flag[i] = true;
    turn = j;
    while (flag[j] && turn == j)
      ;  // busy wait

      /* critical section */
    ...

    flag[i] = false;

      /* remainder section */
    ...
  }
  ```

- Peterson의 해결안이 만족하는 조건
  - Peterson의 해결안은 임계구역 문제의 세 가지 요구 조건을 모두 만족함
  1. **상호 배제(Mutual Exclusion)**: 두 프로세스가 동시에 임계구역에 들어갈 수 없음, `flag[j] == true`와 `turn == j`일 경우 Pᵢ는 기다림
  2. **진행 조건(Progress)**: 임계구역이 비어 있고 한 프로세스만 진입하려 한다면, 바로 진입 가능
  3. **한정된 대기 시간(Bounded Waiting)**: 어떤 프로세스가 임계구역 진입 요청을 했을 때, 무한히 기다리지 않음, `turn` 변수로 순서를 정해줌

- 동작 예시
  - P₀가 `flag[0] = true; turn = 1;`로 설정하고 기다리는 중,
  - P₁도 `flag[1] = true; turn = 0;`로 설정하면,
  - `while (flag[0] && turn == 0)` 조건에 따라 둘 중 하나는 반드시 기다려야 함 → 상호 배제 보장

- 상호 배제를 유지하는 유일한 방법 ?
  - 적절한 동기화 도구를 사용하는 것
  - 이러한 도구에 대한 논의는 하드웨어 프리미티브 지원에서 시작하여 커널 개발자와 응용 프로그램 프로그래머 모두가 사용할 수 있는 추상적 인 고수준 소프트웨어 기반 API 순서로 진행됨

---

## 4. 동기화를 위한 하드웨어 지원

### 1) 메모리 장벽

- 메모리 모델: 컴퓨터 아키텍처가 응용 프로그램에게 제공하는 메모리 접근 시 보장되는 사항을 결정한 방식(강한 순서/약한 순서)
- 문제 배경: CPU나 컴파일러가 성능 최적화를 위해 명령어 순서를 바꿀 수 있음. 이로 인해 스레드 간 예상치 못한 동작이 발생할 수 있음
- 역할: 명령어 실행 순서를 고정시켜줌으로써, 재정렬로 인한 비정상 실행 방지할 수 있음
    - 메모리 장벽 명령어가 실행될 때, 시스템은 후속 적재 또는 저장 연산이 수행되기 전에 모든 적재 및 저장이 완료되도록 함
    - 명령이 재정렬되더라도 메모리 장벽은 향후 적재 또는 저장 작업이 수행되기 전에 저장 작업이 메모리에서 완료되어 다른 프로세서에 보이도록 함
- 예제
  ```c
  x = 100;
  memory_barrier();
  flag = true;
  ```
  - flag에 배정하기 전에 조에 대한 배정이 먼저 실행되도록 함

---

### 2) 하드웨어 명령어

- **test_and_set()**
  - 명령어가 원자적으로 실행됨
  - 만일 두 개의 test_and_set() 명령어가 동시에 실행된다면(각각 다른 코어에서), 이들은 어떤 임의의 순서로 순차적으로 실행될 것임
  ```c
  boolean test_and_set (boolean *target)
  {
    boolean rv = *target ;
    *target = true;
    
    return rv;
  }
  ```

- **compare_and_swap() (CAS)**
  - 두 개의 test_and_set() 명령어가 동시에 실행된다면(각각 다른 코어에서), 이들은 어떤 임의의 순서로 순차적으로 실행됨
  - test_and_set() 명령을 지원한다면, false로 초기화되는 lock이라는 boolean 변수를 선언하여 상호 배제를 구현할 수 있음
  ```c
  int compare_and_swap(int *value, int expected, int new_value)
  {
    int temp = *value;
    
    if (*value == expected)
      *value = new_value;
    
    return temp;
  }
  ```

---

### 3) 원자적 변수

- 정수 및 부울과 같은 기본 데이터 유형에 대한 원자적 연산을 제공
- 카운터가 증가할 때와 같이 갱신되는 동안 단일 변수에 대한 데이터 경쟁이 있을 수 있는 상황에서 상호 배제를 보장하는 데 사용될 수 있음. 단, 모든 상황에서 경쟁 조건을 완벽히 해결하진 않음
- 운영체제 및 병행 응용 프로그램에서 일반적으로 사용되지만 카운터 및 시퀀스 생성기와 같은 공유 데이터 한 개의 갱신에만 제한되는 경우가 많음
- 예제
  ```c
  increment(&sequence)

  void increment(atomic_int *v)
  {
		int temp;
		
    do
    {
      temp = *v;
    }
    while (temp != compare_and_swap(v, temp, temp + 1));
  }
  ```
