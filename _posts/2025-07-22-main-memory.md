---
title: "[운영체제 공룡책 10th] Ch.9 메인 메모리"
description: >-
  Main Memory
date: 2025-07-22 13:00:00 +0900
categories: [OS]
tags: [OS, Operating System]
pin: false
image:
  path: /assets/img/resources/OS/os_cover.png
---

## 1. 배경

### 1) 기본 하드웨어 (Basic Hardware)

- **CPU는 명령어 실행 시 메모리 접근 필요**
  - 메모리에 저장된 명령어와 데이터를 불러와 실행

- Base & Limit Registers
  - **Base Register**: 프로세스가 접근 가능한 시작 주소
  - **Limit Register**: 접근 가능한 범위 (길이)
    - ex) Base = 1000, Limit = 500 → 접근 가능한 주소는 1000 ~ 1499
  - 범위를 벗어나는 접근 시 운영체제는 **트랩(trap)**을 발생시켜 예외 처리 수행
    ![9.2](/assets/img/resources/OS/ch9/9.2.png){: width="500" .normal}

---

### 2) 주소 바인딩 (Address Binding)

- **compile** 시간: 고정된 주소에서 실행, 절대 주소 사용
- **load** 시간: 실행 시 메모리 위치 변경 가능, 상대 주소 사용
- **execution** 시간: 실행 중에도 위치 변경 가능, MMU 필요

  ![9.3](/assets/img/resources/OS/ch9/9.3.png){: width="300" .normal }

---

### 3) 논리(Logical) vs 물리(Physical) 주소 공간

- 논리 주소 vs 물리 주소

  | **논리 주소** | CPU가 생성하는 주소. 사용자 입장에서 보이는 주소 |
  | **물리 주소** | 실제 메모리(RAM)의 주소. MMU를 통해 변환됨 |

- 논리 주소 공간 vs 물리 주소 공간

  | **논리 주소 공간** | 프로세스가 사용할 수 있는 주소 범위 (ex. 0~2³²-1) |
  | **물리 주소 공간** | 실제 RAM의 주소 범위 (ex. 0~2¹⁹-1) |

- **MMU (Memory Management Unit)** 역할: 논리 → 물리 변환

  ![9.4](/assets/img/resources/OS/ch9/9.4.png){: width="400" .normal }

- 변환 방식
  - 물리 주소 = 논리 주소 + base register
  - MMU가 base를 더하고, limit으로 범위 확인
  - 접근 허용 여부 판단

    ![9.5](/assets/img/resources/OS/ch9/9.5.png){: width="400" .normal }

---

### 4) 동적 적재 (Dynamic Loading)

- 프로그램 전체를 메모리에 적재하지 않고, **필요한 루틴만 동적으로 적재**
- 메모리 사용 효율성 향상 가능

---

### 5) 동적 연결 및 공유 라이브러리 (Dynamic Linking & Shared Libraries)

- 공통 라이브러리를 런타임에 연결하는 방식
  - ex) Windows의 .dll, Linux의 .so 라이브러리

- 장점
  - 메모리 절약 (여러 프로세스가 공유)
  - 프로그램 크기 감소

---

## 2. 연속 메모리 할당

### 1) 메모리 보호 (Protection)

- 잘못된 주소 접근 방지를 위해 MMU는 `base` / `limit` 방식 사용
  - 접근 주소가 `base` ~ `base + limit` 범위 밖이면 트랩(trap) 발생

  ![9.6](/assets/img/resources/OS/ch9/9.6.png){: width="400" .normal }

---

### 2) 메모리 할당 (Allocation)

- **가변 파티션 기법**: 메모리를 할당하는 가장 간단한 방법
  - 운영체제는 사용 가능한 메모리 부분과 사용 중인 부분을 나타내는 테이블을 유지함
  - 처음에는 모든 메모리가 사용자 프로세스에 사용 가능, 하나의 큰 사용 가능한 메모리 블록인 **hole**로 간주
  - 각 프로세스가 메모리를 얼마나 요구하며, 사용 가능한 메모리 공간이 어디에 얼마나 있는지 고려하여 공간 할당함

  ![9.7](/assets/img/resources/OS/ch9/9.7.png){: width="400" .normal }

- 메모리 할당 문제에 대한 해결책
  - **최초 적합 (First-fit)**: 가장 처음 맞는 공간에 배치. 빠르지만 단편화 유발
  - **최적 적합 (Best-fit)**: 가장 작은 맞는 공간에 배치. 공간 활용은 좋지만 느림
  - **최악 적합 (Worst-fit)**: 가장 큰 공간에 배치. 큰 공간을 나눠쓰기 유도

---

### 3) 단편화 (Fragmentation)

- 연속 할당에서의 문제: 단편화

- 종류
  - **외부 (External) 단편화**: 빈 공간이 연속되지 않아서 사용 불가
  - **내부 (Internal) 단편화**: 프로세스에 할당된 공간이 조금 남아 사용 불가

- **50% 규칙**: 첫-fit 전략의 경우 외부 단편화로 전체 메모리의 약 1/3이 낭비된다고 예측

- **압축 (compaction)**: 외부 단편화 해결책
  - 메모리 재배열로 연속된 빈 공간 확보
  - 단, CPU 오버헤드 큼

---

## 3. 페이징 (Paging)

### 1) 기본 방법

- 물리 메모리는 동일 크기의 **프레임(frame)**으로, 논리 메모리는 동일 크기의 **페이지(page)**로 나누어짐
  - 프로세스가 실행될 때 그 프로세스의 페이지는 파일 시스템 or 예비 저장장치로부터 가용한 메인 메모리 프레임으로 적재됨
  - 예비 저장장치는 메모리 프레임 or 클러스터(프레임의 묶음)와 동일한 크기의 고정 크기 블록으로 나눠짐

    ![9.8](/assets/img/resources/OS/ch9/9.8.png){: width="450" .normal }

- CPU에서 나오는 모든 주소는 **페이지 번호(p)**와 **페이지 오프셋(d: offset)** 두 부분으로 나누어짐
  ![9.9](/assets/img/resources/OS/ch9/9.9.png){: width="400" .normal }

    - 페이지 번호: 페이지 테이블에서 프레임 번호를 찾기 위한 인덱스로 사용됨
    - 페이지 테이블: 물리 메모리의 각 프레임의 시작 주소를 저장함
    - 페이지 오프셋: 참조되는 프레임 안에서의 위치


- 특징
  - **외부 단편화 없음**
  - 마지막 페이지가 프로세스 크기와 정확히 맞지 않는 경우 내부 단편화 발생
  - 페이지 크기 2^n 단위 일반적 (e.g., 4KB)

- 페이지 크기와 효율
  - 작을 경우: 단편화는 줄지만 페이지 수가 많아져 페이지 테이블이 커짐
  - 클 경우: 테이블은 작지만 단편화는 커짐
  - 일부 시스템은 2MB 이상의 **대형 페이지(Huge Page)**도 지원함

---

### 2) 하드웨어 지원

- MMU & PTBR
  - MMU: 페이지 테이블을 참조하여 논리 주소를 물리 주소로 변환
  - **PTBR** (Page Table Base Register): 현재 페이지 테이블 시작 주소 저장

- **TLB** (Translation Lookaside Buffer): 페이지 테이블 참조를 빠르게 하기 위한 캐시
  - 페이지 번호 → 프레임 번호 매핑을 캐싱 (associative memory)
  - TLB **hit** 시 빠른 변환, **miss** 시 페이지 테이블 접근
  - 성능은 **적중률(hit ratio)**에 따라 좌우됨

    ![9.12](/assets/img/resources/OS/ch9/9.12.png){: width="400" .normal }

- 예시
  - TLB 접근: 10ns, 메모리 접근: 100ns
  - hit ratio = 80%
	```
	EMAT(Effective memory Access Time, 실질 메모리 접근 시간)
	= 0.8 * 10ns + 0.2 * (10 + 100)ns
	= 30ns
	```

---

### 3) 보호

- 페이징 환경에서 메모리 보호는 각 페이지에 붙어있는 보호 비트에 의해 구현됨
  - 이 비트들은 보통 페이지 테이블에 속해 있음
  - 잘못된 접근 시 **memory protection violation** 발생

- **유효/무효 (valid/invalid) 비트**
  ![9.13](/assets/img/resources/OS/ch9/9.13.png){: width="400" .normal }

  - **valid**: 관련 페이지가 프로스세의 합법적인 페이지임을 나타냄
  - **invalid**: 해당 페이지가 프로세스의 논리 주소 공간에 속하지 않음을 나타냄

- **PTLR** (page table length register, 페이지 테이블 길이 레지스터)
  - 프로세스가 자신의 모든 주소 범위를 늘 사용하는 경우는 드묾 → 모든 페이지에 페이지 테이블 항목을 배정하는 것은 낭비
  - 프로세스가 제시한 주소가 유효한 범위 내에 있는지 확인하기 위해 모든 논리 주소 값이 PTLR 값과 비교되며 오류 발견시 트랩 발생시킴


---

### 4) 공유 페이지

- 페이징의 장점은 공통의 코드를 공유할 수 있음
  - 여러 프로세스가 같은 프로그램 코드나 라이브러리를 실행
  - 코드 영역은 읽기 전용이므로 하나만 메모리에 올려서 공유 가능
  - 각 프로세스는 해당 영역을 자신의 페이지 테이블에서 참조

- ex) **libc** 공유
  - libc 코드 → 하나의 물리 프레임
  - 각 프로세스는 페이지 테이블로 해당 프레임을 가리킴 → 메모리 절약

---

## 4. 페이지 테이블의 구조

### 1) 계층적 페이징 (Hierarchical Paging)

- 모든 페이지 테이블을 여러 개의 작은 조각으로 나누는 것

  ![9.15](/assets/img/resources/OS/ch9/9.15.png){: width="300" .normal }


- 문제점: 
  - 32비트 주소 공간 + 4KB 페이지 사용 시 2²⁰ (약 100만)개의 페이지 필요
  - 단일 페이지 테이블: 1M * 4B = 4MB → 너무 큼

- 해결 방법: 
  - 페이지 테이블을 계층 구조로 나눔
  - **2단계 페이징 (Two-level paging)**

- 32비트 논리 주소 분할

  | 필드        | 비트수 | 설명 |
  |-------------|--------|------|
  | `p1`        | 10     | 바깥(outer) 페이지 테이블 인덱스 |
  | `p2`        | 10     | 안쪽(inner) 페이지 테이블 인덱스 |
  | `d`         | 12     | 페이지 오프셋 |

- 64비트 주소 공간
  - 2단계로도 부족 → 3단계 또는 7단계 필요 (ex. UltraSPARC)

---

### 2) 해시 페이지 테이블 (Hashed Page Tables)

- 해시 함수를 사용하여 페이지 번호를 해시 테이블 인덱스로 변환

  ![9.17](/assets/img/resources/OS/ch9/9.17.png){: width="350" .normal }

- 특징
  - 32bit 주소 공간보다 클 때 효율적
  - 해시 충돌 시 연결 리스트로 해결

- 해시 테이블 항목 구성
  - 논리 페이지 번호
  - 물리 프레임 번호
  - 다음 항목 포인터

- 변형 구조: **클러스터 페이지 테이블**
  - 각 항목이 여러 페이지를 커버
  - 연속된 주소 공간을 커버할 때 효율적

---

### 3) 역 페이지 테이블 (Inverted Page Table)

- 기존 구조의 문제: 프로세스마다 페이지 테이블 → 메모리 낭비
- 해결 방법: 시스템 전체에 하나의 테이블만 사용

- 구조

  ![9.18](/assets/img/resources/OS/ch9/9.18.png){: width="350" .normal }

  - 각 항목: 물리 프레임 하나에 대응
  - 저장 정보: `<process-id, page-number>`
  - 논리 주소 접근 시 테이블 탐색 필요

- 단점
  - 탐색 시간 오래 걸림 → 해결책: TLB 사용
  - 다중 프로세스에서 같은 가상 주소를 가질 수 없음

---

### 4) Oracle SPARC Solaris

- 환경: 64비트 SPARC CPU + Solaris OS
- 방법: 해시 페이지 테이블 사용

- **TSB (Translation Storage Buffer)**
  - 자주 사용하는 변환 캐시
  - TLB 미스 시 → TSB 탐색 → 해시 테이블 탐색
  - MMU에 의해 자동으로 TLB에 로드됨

- 장점
  - 모든 프로세스가 공유하는 하나의 해시 테이블 유지
  - 페이지 테이블 크기 감소 + 효율적 변환

---

## 5. 스와핑


### 1) 기본 스와핑

![9.19](/assets/img/resources/OS/ch9/9.19.png){: width="350" .normal }
- 전체 프로세스를 디스크로 내보내고, 다시 메모리로 가져오는 방식
  -  user space가 **스와핑 영역**으로 이동하고 필요 시 복귀
- 장점: 물리 메모리보다 더 많은 프로세스를 수용할 수 있도록 물리 메모리가 초과 할당될 수 있음


- 문제점
  - I/O 비용이 크고, 전체 데이터를 이동하므로 속도가 느림
  - 적은 빈도로 사용됨

---

### 2) 페이징에서의 스와핑

![9.20](/assets/img/resources/OS/ch9/9.20.png){: width="350" .normal }
- 전체가 아닌 **일부 페이지**만 디스크로 옮겨서 스와핑함. 프로세스 A와 B가 **일부 페이지만 메모리에 존재**하며 나머지는 디스크에 있음
  - **페이지-아웃**: 페이지를 메모리에서 백업 저장장치로 이동시킴
  - **페이지-인**: 페이지를 백업 저장장치에서 메모리로 이동시킴
- 현대 OS (Linux, Solaris, Windows)에서 사용됨
- 장점: 전체 이동보다 유연하고 효율적

---

### 3) 모바일 시스템에서의 스와핑

- 모바일 OS는 어떠한 형태의 스와핑도 지원하지 않는 것이 일반적
  - Why ?
    - 모바일 장치들은 하드디스크보다 **플래시 메모리**를 사용함 → 저장 공간 줄어듦
    - 낮은 I/O 성능: 플래시 메모리가 사용 불가할 때까지 허용되는 쓰기 횟수가 정해져 있음
  - 대안
    - iOS: 스와핑을 사용하는 대신 가용 메모리가 정해진 임계값보다 떨어지면 응용에 할당된 메모리를 자발적으로 반환하도록 요청(스택과 같은 변경된 데이터는 제거 X)
    - Android: iOS와 유사한 방식 채택, 가용 메모리가 부족하다면 프로세스 종료 가능. 프로세스를 종료하기 전에 응용의 상태를 플래시 메모리에 저장하여 후에 빠르게 재시작할 수 있게함